# Chapter1

<br/>

## 함수형 프로그래밍이란?

`수학 함수`를 사용하고 `부수효과`를 피하는 것이 특징인 프로그래밍 패러다임

`부수효과` 없이 `순수 함수`만 사용하는 프로그래밍 스타일

<br/>

> **부수효과(side effect)**

- 함수가 리턴값 이외에 하는 모든 일을 말한다.

- 예) 메일 보내기, 전역상태 수정하기
- 부수 효과는 함수를 부를 때마다 발생하기 때문에 문제가 발생할 수 있다.

<br/>

> **순수 함수**

- 인자에만 의존하고 부수 효과가 없는 함수이다.

- 항상 같은 결과를 돌려준다.
- 수학 함수라고 할 수 있다.

<br/>

## 액션, 계산, 데이터로 구분하기

이 책에서는 함수형 프로그래밍 개념을 쉽게 설명하기 위해 코드를 `액션, 계산, 데이터`로 구분하고 있다.

> **액션**

- `실행 시점`이나 `횟수`에 의존한다.

- 상태 변경을 일으키거나 `부수효과`를 포함하는 함수
- UI를 변경시키거나 서버에 요청을 보내는 것은 액션이다.

<br/>

> **계산**

- 입력값으로 출력값을 만드는 행위다.

- 같은 값을 입력하면 항상 같은 결과값을 반환한다.
- 상태를 계산하거나 변환하는 순수 함수

<br/>

> **데이터**

- 이벤트에 대해 기록한 사실이다.

- 정적이고 해석이 필요하다.
- 컴포넌트의 상태나 props 등 불변의 데이터

<br/>

리액트를 기준으로 예시를 들어보자.

```tsx
// 데이터: 컴포넌트의 상태
const initialState = {
  todos: [],
};

// 계산: 순수 함수로 상태를 업데이트
function addTodo(state, todo) {
  return {
    ...state,
    todos: [...state.todos, todo],
  };
}

function handleCreateTodoDispatch(dispatch, todo) {
  // 1. 상태 업데이트 (계산)
  const newState = addTodo(getState(), todo);

  // 2. 상태 변경 (액션)
  dispatch({ type: 'ADD_TODO', payload: newState });

  // 3. 서버에 todo 추가 요청 (액션)
  createTodoOnServer(todo)
    .then(() => {
      // 4. 성공 시 알림 (액션)
      toast.success('Todo added successfully');
    })
    .catch(() => {
      // 5. 실패 시 롤백 및 알림 (액션)
      toast.error('Failed to add todo');
    });
}
```

<br/>

## 함수형 사고

함수형 사고는 소프트웨어 문제를 해결하기 위해 사용하는 기술과 생각이다.

그 중 함수형 프로그래밍에서 가장 중요하다고 생각하는 두 가지 개념이 있다.

1. `액션, 계산, 데이터 구분`

2. `일급 추상`

<br/>

# Chapter2

<br/>

## 계층형 설계

`계층형 설계`는 소프트웨어 시스템을 계층 구조로 분리하여 각 계층이 특정 역할과 책임을 담당하도록 설계하는 방법이다. 각 계층은 그 아래에 있는 계층을 기반으로 만들어진다.

이 책에서는 `비즈니스 규칙, 도메인 규칙, 기술 스택 계층`으로 나누며 자주 바뀌지 않는 것을 하위 계층으로 둔다.

1. 비즈니스 규칙

   - 이번 주 메뉴 (특별 메뉴 조리법)
   - 이번 주 사야할 것 (재료를 어디서 구입할지)

2. 도메인 규칙
   - 피자 만들기 (조리법 순서)
   - 재료 목록 (재료 목록에 대한 동작)
3. 기술 스택

   - 자바스크립트 (객체, 순서)

   <br/>

## 일급 추상

### 타임라인 다이어그램

타임라인 다이어그램은 시간에 따라 변하는 액션을 시각화하는 방법이다.

다음과 같은 방식으로 액션을 시간 순서에 따라 정리한다.

```tsx
1. 주문 접수
2. 반죽 만들기
3. 반죽 펴기
4. 소스 만들기
5. 소스 뿌리기
6. 치즈 갈기
7. 치즈 뿌리기
8. 오븐에 넣기
9. 10분 기다리기
10, 서빙
```

피자 만들지도 않았는데 서빙할 수는 없는 것처럼 `액션`은 `실행 시점`에 의존한다.

<br/>

### 분산 시스템

분산 시스템에서 독립된 액션의 실행 순서는 어떻게 될지 모른다.

타임라인을 서로 맞추지 않은 분산 시스템은 `예측 불가능한 순서`로 실행된다.

이를 해결하기 `위해` 커팅을 사용한다.

<br/>

### 커팅

타임라인 커팅은 여러 타임라인이 동시에 진행될 때 서로 순서를 맞추는 방법이다.

`고차동작`으로 구현되며 각 타임라인은 독립적으로 동작하고 작업이 완료되면 다른 작업의 완료를 기다린다.

<br/>

# Chapter3

<br/>

## 액션과 계산, 데이터

1. 문제를 `액션, 계산, 데이터`로 나눠 생각해보기

2. 최대한 액션에서 계산을 빼내기
3. 최대한 계산에서 데이터를 분리하기
4. 숨어 있는 액션 찾아내기

<br/>

> 참조 투명성

- 어떤 표현식이 `동일한 입력에 대해 항상 동일한 출력을 반환`하고, `부수효과가 없음`을 의미한다.

- `참조 투명성`을 가진 표현식은 그 자체를 값으로 대체해도 프로그램의 행동이 변하지 않는다.
- 안정성, 유지보수성, 병렬 처리의 효율성을 높이는 개념이다.

<br/>

`참조 투명성`을 가진 함수 예시

```tsx
function add(a, b) {
  return a + b;
}

const result = add(2, 3); // result는 항상 5
```

<br/>

`참조 투명성`을 가지지 않은 함수의 예시

```tsx
let count = 0;

function increment() {
  count++;
  return count;
}

// increment() 는 호출할 때마다 다른 값을 반환하며 부수효과가 있다.

const result1 = increment(); // result1는 1
const result2 = increment(); // result2는 2
```

<br/>

## 장보기 과정 분리하기

장보기 과정을 `액션, 계산, 데이터`로 분리해보자

```tsx
1. 냉장고 확인하기 (액션)
	- 냉장고 확인하는 시점에 따라 냉장고 제품이 다르기 때문
2. 운전해서 상점으로 가기 (액션)
	- 시간에 따라 도착 시간이 다르거나 소모되는 연료가 다름
3. 필요한 것 구입하기 (액션)
	- 시점에 따라 필요한 것이 품절이 될 수 있음
4. 운전해서 집으로 오기 (액션)
	- 현재 집에 있다면 성립 불가능. (시점에 의존)
```

단순한 과정은 액션으로만 분류할 수 있지만 좀 더 단계별로 살펴보면 다르다.

<br/>

### 냉장고 확인하기

- 냉장고 확인하는 일을 시점에 따라 결과가 다르기 때문에 `액션`이다.

- 냉장고에 제품들은 `데이터`다.

### 운전해서 상점가기

- 운전해서 상점으로 가는 것은 `액션`이다.

- 상점 위치나 경로는 `데이터`다.

### 필요한 것 구입하기

- 구입하는 것도 `액션`이다.

- 구입과정을 단계별로 나누어보자.

  ```tsx
  현재 재고 : 데이터
  필요한 재고 : 데이터
  재고 빼기 : 계산
  장보기 목록 : 데이터
  목록에 있는 것 구입하기 : 액션

  현재 재고 - 필요한 재고 = 장보기 목록
  ```

<br/>

<b>[4줄 요약]</b>

1. 액션과 계산, 데이터는 어디에나 적용 가능하다.

2. 액션 안에는 계산과 데이터, 또 다른 액션이 숨어 있을 수 있다.
3. 계산은 더 작은 계산과 데이터로 나누고 연결할 수 있다.
4. 데이터는 데이터만 조합할 수 있다.

<br/>

## 유저들에게 쿠폰 전송하기

```tsx
interface User {
  email: string;
  rec_count: string; // 추천 카운트
}

interface Coupon {
  coupon: string;
  code: string;
  rank: 'bad' | 'good' | 'best';
}

interface Message {
  from: string;
  to: string;
  subject: string;
  body: string;
}
```

<br/>

1. 추천수가 10 이상인 유저들은 `best`유저다.

2. `best` 쿠폰은 best 유저들에게 전달된다.
3. `good` 쿠폰은 모든 유저에게 전달된다.
4. `bad` 쿠폰은 아무에게도 전달되지 않는다.

<br/>

## 쿠폰 보내는 과정 구현하기

`구독자의 등급을 평가 (계산)`

```tsx
function subCouponRank(subscriber) {
  if (subscriber.rec_count >= 10) {
    return 'best';
  } else {
    return 'good';
  }
}
```

<br/>

`특정 등급의 쿠폰 목록을 선택 (계산)`

```tsx
function selectCouponsByRand(coupons, rank) {
  let ret = [];

  for (let i = 0; i < coupons.length; i++) {
    const coupon = coupons[i];

    if (coupon.rank === rank) {
      ret.push(coupon.code);
    }
  }

  return ret;
}
```

<br/>

이제 `구독자`와 `good 쿠폰 목록` , `best 쿠폰 목록` 을 사용해서 `이메일`을 만든다.

<br/>

`구독자가 받을 이메일을 계획 (계산)`

```tsx
function emailForSubscriber(subscriber, goods, bests) {
  const rank = subCouponRank(subscribrer);

  if (rank === 'best') {
    return {
      from: 'xxx@coupon.do',
      to: subscriber.email,
      subject: '고맙다.',
      body: '땡큐',
    };
  } else {
    return {
      from: 'xxx@coupon.do',
      to: subscriber.email,
      subject: '일반 쿠폰이다',
      body: '일 좀 해라',
    };
  }
}
```

<br/>

`보낼 이메일 목록 준비하기 (계산)`

```tsx
function emailsForSubscribers(subscribers, goods, bests) {
  const emails = [];

  return emails.map(email => emailForSubscriber(subscriber, goods, bests));
}
```

<br/>

`이메일 보내기 (액션)`

```tsx
function sendIssue(){
	const coupons = fetchCouponFromDB();

	// 이메일 순회하면서 쿠폰 뿌리기
	...
}
```

<br/>

> **이메일 보내기 전에 모든 이메일 만드는 이유**

- 사용자가 많다면 메모리 부족으로 시스템이 동작하지 않을 수 있다.

- 하지만 동작하지 않는다고 단정할 수도 없다.
- 실행 결과를 알기 전에 미리 최적화 하는 것은 좋지 않다.
- 확장성은 고려하면 좋다.
- 예를 들어 `emailsForSubscribers()` 를 20개씩 chunking하는 식으로 동작시키면 된다. 즉 계산은 고치지 않도록 작성해야한다. 다만 액션이 수정될 뿐이다.

<br/>

> **데이터**

- 데이터는 이벤트에 대한 사실이다. 일어난 일의 결과를 기록한 것이다.
- 숫자나 문자, 배열, 객체
- 데이터 구조로 의미를 담을 수 있다.

<br/>

> **데이터의 장점**

- 직렬화
- 동일성 비교
- 자유로운 해석

<br/>

> **데이터의 단점**

- 해석하지 않은 데이터는 쓸모없는 바이트다.

<br/>

> **불변성**

- `카피-온-라이트` : 변경할 때 복사본을 만든다.
- `방어적 복사` : 보관하려고 하는 데이터의 복사본을 만든다.

<br/>

---

<br/>

> **계산**

- 계산은 입력값으로 출력값을 만드는 것이다.
- 실행시점과 횟수 관계없이 항상 같은 입력값에 대해 같은 출력값을 돌려준다.

<br/>

> **계산의 장점**

- 테스트하기 쉽다.
- 기계적인 분석이 쉽다.
- 조합하기 좋다. 여러 개의 계산을 조합해 더 큰 계산을 만들 수 있다.

<br/>

> **계산의 단점**

- 계산과 액션은 실행하기 전에 어떤 일이 발생할지 알 수 없다.
- 코드를 읽으면 예상이 되긴하나, 소프트웨어 측면에서는 블랙박스다.
- 꼬우면 데이터를 사용한다.

<br/>

---

<br/>

> **액션**

- 외부에 영향을 주거나 받는 것을 말한다.

- 실햄 시점과 횟수에 의존한다. (순서 및 반복)
- `순수하지 않은 함수` 또는 `부수 효과 함수`라고 한다.
- 예) 이메일 보내기, 계좌에서 인출하기, 서버에 요청 보내기, 전역 변경
