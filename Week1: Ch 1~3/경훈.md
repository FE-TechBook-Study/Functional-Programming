# 경훈

## 1. 함수형 프로그래밍이란?

Feat) 위키피디아

1. 수학 함수를 사용하고 부수 효과를 피하는 것이 특징인 프로그래밍
2. 부수 효과 없이 순수 함수만 사용하는 프로그래밍

### 부수 효과란?

- 함수에서 결과 값을 주는 것 외에 행동

### 순수 함수란?

- 부수 효과 없이 결과 값이 인자에 의존하는 함수

→ 정의에 따르면 함수형 프로그래머는 항상 부수 효과를 피하고 순수 함수만 사용해야 할 것 같지만, 실제 함수형 프로그래머는 부수 효과와 순수하지 않은 함수를 사용합니다.

## 2. 실용적인 측면에서 함수형 프로그래밍의 정의의 문제점

1) 부수 효과는 필요합니다. 필요할 때는 사용하는 것이 좋습니다.

2) 함수형 프로그래밍은 부수 효과를 잘 다룰 수 있는 기술들이 많이 존재합니다.

3) 정의에서는 함수형 프로그래밍이 수학적이라 실제 소프트웨어 개발에서 사용하지 않는 것 처럼 느껴지지만 함수형 프로그래밍은 실용적입니다.

## 3. 함수형 프로그래밍에서는 코드를 액션, 계산, 데이터 3가지로 구분합니다.

### 액션

- 액션은 실행 시점, 횟수 또는 둘 다에 의존합니다.
1. 시간이 지남에 따라 안전하게 상태를 바꿀 수 있는 값
2. 순서를 보장하는 방법
3. 액션이 정확히 한 번만 실행되게 보장하는 방법

### 계산

- 입력 값을 계산해 출력하는 것. 어디서 계산해도 결과는 같고 외부에 영향을 주지 않습니다. 언제든지 몇 번 불러와도 안전합니다.
1. 정확성을 위한 정적 분석
2. 소프트웨어에서 쓸 수 있는 수학적 지식
3. 테스트 전략

### 데이터

- 이벤트에 대한 사실을 기록한 것
1. 효율적으로 접근하기 위해 데이터를 구성하는 방법
2. 데이터를 보관하기 위한 기술
3. 데이터를 이용해 중요한 것을 발견하는 원칙

⇒ 이렇게 3가지로 구분하게 되면 요즘 유행하는 분산 시스템과 잘 어울립니다. 실행 시점이나 횟수에 의존하는 코드를 없애면, 코드를 더 쉽게 이해 가능하고, 심각한 버그를 막을 수 있습니다. 액션을 코드 전체에 영향을 주지 않도록 격리 시키자.

### 계층형 설계란?

- 계층을 분리해 가장 위는 코드의 의존성이 거의 없는 코드, 아래는 위에 있는 코드보다 의존성이 많은 코드로 계층을 나눕니다. 이 아키텍처 패턴은 계층형 설계라고 합니다. 계층형 설계로 만든 코드는 테스트, 재사용, 유지보수가 쉽습니다.

### 분산시스템을 타임라인으로 시각화 하기

- 분산 시스템을 만들기 위해 액션을 타임라인으로 나누었습니다.
- 타임라인이 예측 불가능한 순서로 실행되는 이슈가 생깁니다.

1. 타임라인의 실행 순서를 맞추자
2. 액션이 실행되는 시간은 주요하지 않습니다. 각각의 타임라인은 순서와 관계 없이 만들어야 합니다.
3. 드물지만 타이밍이 어긋납니다. 타임라인은 항상 옳바른 결과를 보장해야 합니다.
4. 타임라인 다이어그램으로 시스템의 문제를 알 수 있습니다.

### 커팅이란?

- 타임라인이 동시에 진행될 때 서로 순서를 맞추는 방법입니다.
- 커팅을 통해 일정 작업들이 끝날 때 까지 기다립니다.

### 결론

- 타임라인 커팅으로 서로 다른 작업들을 쉽게 이해 가능합니다. 더 짧아진 타임라인을 실행 순서에 상관없이 이해가 가능합니다.
- 타임라인 다이어그램을 사용하면 시간에 따라 진행하는 작업을 쉽게 이해 가능합니다. 분산 시스템을 시각화하기 좋습니다.
- 타임라인 다이어그램은 유연합니다. 동시에 진행되는 작업을 쉽게 모델링 가능합니다.

## Chapter3 액션과 계산, 데이터 차이를 알기

### 액션

- 실행 시점과 횟수에 의존합니다 : 말 그대로 횟수와 실행 시점에 따라 데이터가 결과 값이 달라질 수 있습니다.
- 부수 효과가 존재합니다. ex) alert, toast, 상태 변경으로 인한 사이드 이펙트

```jsx
// [action] : 부수 효과가 있는 알람 함수
const alertAction = message => {
  alert(message);
};

// [계산] : 더하기 함수 (참조 투명성이 없음)
const sumNumberCal = numbers => {
  const sum = numbers.reduce(add, 0);
  return sum;
};

// [계산] : 더하기 함수 (참조 투명성이 없음)
const add = (x, y) => x + y;

// [계산] : 랜덤으로 길이가 5인 number[] 의 배열을 만들어줌.
const randomNumbersCal = () => {
  const randomNumbers = Array.from(
    { length: 5 },
    () => Math.floor(Math.random() * 100) + 1,
  );
  return randomNumbers;
};

function App() {
  // [액션, 계산]
  const generateRandomNumbersAction = () => {
    const randomNumbers = randomNumbersCal();
    const sumResult = sumNumberCal(randomNumbers);

    alertAction(`더한 숫자는 ${sumResult} 입니다.`);
  };

  return (
    <>
      <button onClick={() => generateRandomNumbersAction()}>번호 뽑기</button>
    </>
  );
}

export default App;
```

### 계산

- 계산은 입력 값을 통해 출력 값을 만드는 것.
- 실행 시점과 횟수에 관계없이 항상 같은 입력 값에 대해 같은 출력 값을 뱉어냄. : 시점과 실행 횟수에 대한 걱정을 하지 않아도 됩니다.
- 동일한 입력 값에 동일한 출력값이 출력되기 때문에 테스트하기 쉬움.
- 계산은 조합하기 쉬움. (reduce, sum)

### 데이터

- 이벤트에 대한 결과 값을 의미합니다.
- ex) 숫자, 문자, 배열, 객체 등
- 불변성을 띔. 불변 데이터 구조를 만들기 위해 2가지 방법을 사용
    - 카피-온-라이트 : 데이터 변경 시 원본 데이터를 변경하지 않고 새로운 복사본을 만드는 방식.
    - 방어적 복사 : 객체를 전달할 때 원본 객체를 보호하기 위해 복사본을 전달하는 방식.
    
    ```jsx
    const [items, setItems] = useState(['Item 1', 'Item 2', 'Item 3']);
    
    const addItem = () => {
      // 새로운 아이템 배열을 생성하여 상태를 업데이트
      const newItems = [...items, `Item ${items.length + 1}`];
      setItems(newItems);
    };
    ```
    
- 데이터는 직렬화 가능

```jsx
const serializedPerson = JSON.stringify(person);
console.log(serializedPerson);
// 직렬화 : {"name":"Alice","age":30,"city":"Wonderland"}

// 역직렬화: JSON 문자열을 다시 객체로 변환
const deserializedPerson = JSON.parse(serializedPerson);
console.log(deserializedPerson);
```

- 데이터를 액션과 계산과 다르게 비교 가능함.

### 결론

- 함수형 프로그래머는 액션, 계산, 데이터를 분리하는게 좋다?
- 액션은 실행 시점이나 횟수에 의존함. 또한 외부 상태에 영향을 주거나 받음.
- 가능한 액션에서 계산이 있다면 분리해서 작성.
- 계산은 테스트하기 쉬움.

### 개발 과정에서 액션, 계산, 데이터를 구분하는 기술 (단계)

1. 문제에 대해 생각할 때 : 문제를 액션, 계산, 데이터로 나눠보면 코드를 작성할 때 특별히 주의해야 할 부분(액션)과 데이터로 처리해야 할 부분, 결정을 내려야 하는 부분(계산)을 명확히 알 수 있습니다.
2. 코딩할 때 : 코딩할 때도 구분할 수 있습니다. 함수형 프로그래머는 최대한 액션에서 계산을 빼내려고 합니다. 또 계산에서는 데이터를 분리할 수 있는지 생각합니다. 더 나아가 액션이 계산이 될 수 있는지, 계산이 데이터가 될 수 있는지 고민합니다. 
3. 코드를 읽을 때 : 액션, 데이터, 계산 어떤 것에 속하는지 확인합니다. 특히 액션은 시간에 의존하기 때문에 조심합니다.

### 일상 생활 속 액션, 계산, 데이터 해보기

![Untitled (2)](https://github.com/FE-TechBook-Study/Functional-Programming/assets/68219145/0161f532-6c7e-41b5-9161-b39ad985337f)

1. 액션, 계산, 데이터는 어디에나 존재합니다.
2. 액션 안에 계산과 데이터, 또 다른 액션이 존재할 수도 있습니다.
3. 계산은 더 작은 계산과 데이터로 나누고 연결 가능합니다.
4. 데이터는 데이터만 조합 가능합니다.
5. 계산은 때로 우리 머리 속에서 일어납니다.

- 가능한 계산을 하려는 이유 ⇒ 테스트하기 쉽기 때문.
    - 이메일을 보내고 결과를 통해 테스트를 하기는 어렵지만 이메일을 보내기 전에 이메일 목록 데이터를 테스트하는 것은 쉽습니다.
- 액션은 코드 전체로 퍼집니다. ⇒ 액션이 들어간 함수는 그 자체가 액션입니다. 조심스럽게 함수형 사고를 고려해서 사용합니다.

### 액션은 다양한 형태를 가지고 있습니다.

```jsx
alert("Hello") // 팝업 창이 뜨는 것은 액션

console.log("hello") // 콘솔 출력도 액션

new Date() // 시점에 날짜와 시간을 초기화 하기 때문에 호출되는 시점에 따라 다른 값을 가지기 때문에 액션

// 표현식 및 상태 수정 및 할당은 다른 코드에 영향을 주기 때문에 액션.
```

### Action 무엇입니까?

- 외부 세계에 영향을 주거나 받는 것을 의미. 실행 시점과 횟수에 의존.

### 어떻게 구현하나요?

- 함수로 구현. 계산도 함수로 구현하기 때문에 구분하기 쉽지 않다.

### 어떻게 의미를 담을 수 있나요?

- 이메일 보내기
- 계좌에서 인출하기
- 전역 변수 변경하기
- ajax 요청 보내기

### 결론

- 액션은 다르기 쉽지 않고, 가능한 적게 사용하고 가능한 작게 만들어야 합니다. 액션에서 액션과 관련 없는 코드들은 계산으로 빼거나 제거합니다.
