# 상현
# 4. 액션에서 계산 빼내기

함수의 출력은 명시적(인자, 리턴값)이거난 암묵적(인자 외의 다른 입력, 리턴값 외 다른 출력)일 수 있음

- 암묵적 입력 또는 출력이 하나라도 있으면 액션 ⇒ “부수효과”가 존재
- 그외는 단순 함수

기존 함수에서 함수를 추출하여 다른 함수로 분리하는 행동을 **서브루틴 추출하기(extract subroutine).** 그러나 기존 함수 자체의 행동 자체가 바뀌어서는 안됨

서브루틴 추출의 단계

1. 계산 코드를 찾아서 분리
2. 새 함수에 암묵적 입력과 출력 찾기
3. 암묵적 입력은 인자로 암묵적 출력은 리턴값으로 변경

```tsx
// 기존
function calculate(a, b){
	const c = a + b;
	const d = c * 12
	......
}
// 변경
function addThenTweleve(a, b){
	const c = a + b;
	return c * 12
}

function calculate(a, b){
	const d = addThenTweleve(a, b)
}
```

코드가 더 적어야 좋은 것이 아닌가?

- 일반적으로 적은 것 이 더 좋지만, 분리를 함으로써 테스트 및 재사용성 증가

다른 곳에서 쓰지 않더라도 계산으로 분리하는 것이 중요한 것인가?

- 함수형 목적에는 어떤 것을 더 작게 분리해서 더 작게 만드려고 하는 것이 있다. 작은 것은 테스트하기 쉽고 재사용하기 쉽고 이헤하기 쉬움

# 5. 더 좋은 액션 만들기

> **목적:   
암묵적 입력과 출력을 제거해서 재사용하기 좋은 코드를 만드는 방법을 탐색  
복잡하게 엉킨 코드를 풀어 더 좋은 구조로 만드는 법을 공부**

어떤 함수에 암묵적 입력과 출력이 있다면 다른 컴포넌트와 강하게 연결된 컴포넌트라고 할 수 있다. 또한, 암묵적 입력과 출력이 적을 수록 테스트하기 쉽고 재사용성 증가

### 계산 분류하기

- 함수에 특별한 문제가 없어도 꺼낼 것이 있다면 분리하는 것이 좋다. 그리하면 더 좋은 설계가 된다.
- 설계는 엉켜있는 코드를 푸는 것
- 계산을 **유틸리티 및 비즈니스 규칙 총 2개로 분리 가능**

(p98)설계는 엉켜있는 코드를 푸는 것이다
why? 재사용, 유지보수, 테스트하기 쉬움

계산을 다음과 같이 나눌 수 있음

- 유틸리티, 비즈니스 규칙

## 질문 또는 발표?

리액트에서 setter함수를 다른 컴포넌트의 props로 넘겨주는 것은 강하게 연결되어 있기에 지양하는 것이 좋다고 인식. 그렇다고 특정 컴포넌트가 특정상황에 강하게 연결되어 있는데도 함수로 감싸서 넘기는 것이 더 맞다고 판단하는지? 아니면 단순히 setter함수로 넘기는 것이 더 좋을지?

```tsx
const CompA = () => {
	const [one, setOne] = useState(1)
	const handleIncrease = () => {
		setOne(prev => prev + 1)
	}
	return(
		<div>
			<CompB setOne={setOne} />
			<CompC handleIncrease={handleIncrease} />
		</div>
	)
}
```