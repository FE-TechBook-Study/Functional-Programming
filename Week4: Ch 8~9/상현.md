# 상현
## 8. 계층형 설계 1

목적:

- 소프트웨어 설게 대한 실용적인 정의
- 계층혈 설계를 이해하고 어떤 도움이 있는 지 확인
- 깨끗한 코드를 만들기 위해 함수 추출방법 확인
- 계층을 나눠서 소프트웨어를 설계하면 왜 더 나은 생각을 할 수 있는 지 확인

### 계층형 설계

소프트웨어를 계층으로 구성하는 기술

- 각 계층에 있는 함수는 바로 아래 계층에 있는 함수를 이용해 정의

### 계층형 설계 패턴

1. 직접 구현: 함수 본문에서 적절한 구체화 수준에서 해결. 너무 구체적이라면 냄새나느 코드
2. 추상화 벽: 중요한 세부 구현을 감추고 인터페이스 제공. 고수준의 추상화 단계만 생각하기 되기 때문에 두되 요량 한계 극복
3. 작은 인터페이스: 개념을 나타내는 중요한 인터페이스는 작고 강력한 동작으로 구성
4. 편리한 계층: 그냥 좋아서 계층 추가X. 코드와 그 코드가 속한 추상화 계층은 작업할 때 편리해야 함

### 패턴 1: 직접 구현

직접 구현 패턴을 사용하면 비슷한 추상화 계층에 있는 함수를 호출

```tsx
// 호출 그래프를 통해서 바라본 함수 구조

// BEFORE
function feeTieClip(cart){
	var hasTie = fasle;
	var hasTieClip = fasle;
	// for loop라는 "언어 함수"
	for(var i = 0; i < cart.length, i++){
		// array index를 조회하는 "언어 함수"
		vart item = cart[i];
		if(item.name === "tie"){
			hasTie = true;
		}
		if(item.name === "tie clip"){
			hasTieClip = true;
		}
	}
	if(hasTie && !hasTieClip){
		// 사용자가 정의한 "사용자 함수" 2개
		var tieClip = make_item("tie clip", 0);
		return add_item(cart, tieClip)
	}
	return cart;
}

// AFTER
function feeTieClip(cart){
	var hasTie = isInCart(cart, "tie");
	var hasTieClip = isInCart(cart, "tie clip");
	if(hasTie && !hasTieClip){
		// 사용자가 정의한 "사용자 함수" 2개
		var tieClip = make_item("tie clip", 0);
		return add_item(cart, tieClip);
	}
	return cart;
}
```

## 9. 계층형 설계 2

목적

- 코드를 모듈화하기 위해 추상화 벽을 만드는 법
- 좋은 인터페이스가 어떤 것이고 어떻게 찾는지 확인
- 설계 종료시점 확인
- 계층형 설계가 유지보수와 테스트, 재사용에 도움이 되는지 이해

### 패턴 2: 추상화 벽

서로 신경쓰지 않아도 되는 구체적인 것을 숨김으로써 사용과 결과에만 집중

사용하기 좋은 때:

1. 쉽게 구현을 바꾸기 위해
2. 코드를 읽고 쓰기 쉽게 만들기 위해
3. 팀 간에 조율해야 할 것을 줄이기 위해
4. 주어진 문제에 집중하기 위해

### 패턴3: 작은 인터페이스

새로운 기능을 만들 때 하위 계층에 기능을 추가하거나 고치는 것보다 상위 계층에 만드는 것이 작은 인터페이스 패턴에 부합

추상화 벽에 만든 함수는 인터페이스라고 생각을 할 때, 

추상화 벽을 작게 만들어야 하는 이유

1. 추상화 벽에 코드가 많을 수록 구현이 변경되었을 때 고쳐야 할 것이 많음
2. 추상화 벽에 있는 코드는 낮은 수준의 코드이기 때문에  더 많은 버그 존개 가능
3. 낮은 수준의 코드는 이해하기 더 어려움
4. 추상화 벽에 코드가 많을수록 팀 간 조율해야 할 것도 다수
5. 추상화 벽에 인터페이스가 많으면 알아야 할 것이 많아 사용하기 어려움

### 패턴4: 편리한 계층(comfortable layer)

편리한 계층 패턴은 언제 패턴을 적용하고 또 언제 멈춰야 하는지 실용적인 방법을 알려줌

- 계층을 만드는 작업이 그냥 좋아서 만들면 안 됨
- 지금 작업하는 코드가 편하다면 설계를 멈춤. 그러나 구체적인 것을 너무 많이 알아야 하거나 코드가 지저분하다고 느껴진다면 다시 패턴을 적용

### 호출 그래프로 알 수 있는 것

![Untitled](https://upload.wikimedia.org/wikipedia/commons/2/2f/A_Call_Graph_generated_by_pycallgraph.png)

비기능적 요구사항을 보여줌

1. 유지보수성: 요구 사항이 바뀌었을 때 가장 쉽게 고칠 수 있는 코드는 어떤 코드?
    1. 가장 고치기 쉬운 것은 상위 계층. 반대로 어려운 것은 하위 계층. 상위 계층은 다른 함수가 호출하지 않고, 하위 계층은 다른 함수가 호출하고 있기에
2. 테스트성: 어떤 것을 테스트 하는 것이 가장 중요?
    1. 아래 계층의 코드들. 위 계층들이 참조하고 있기에 아래 계층을 테스트하면 위 계층의 정확성을 보증하게 되며 위 계층들은 바뀔 수 있기에 테스트의 유효기간이 짧음
3. 재사용성: 어떤 함수가 재사용하기 좋음?
    1. 아래 계층의 코드들.

먼저 가장 고치기 쉬운 코드는 가장 위에 있는 코드. 왜냐하면 다른 함수가 호출하지 않기 때문에.

## 발표할 것.

어떻게 보면 이번 장에서 있는 내용과 많이 겹치는 영상이 있기에 본 적이 없다면 다음 영상을 추천.

[실무에서 바로 쓰는 Frontend Clean Code](https://toss.im/slash-21/sessions/3-3)

- toss가 바라보는 클린 코드?
    - 단일 책임: 함수는 하나의 기능만
    - 좋은 함수 이름: 함수 이름을 보고 기능을 바로 유추
    - 선언적과 명령형의 적재적소: 선언적 프로그래밍의 장단점, 명령형 프로그래밍의 장단점을 알고 때에 따라서 사용
    - 같은 추상화 단계: 추상화 단계가 같은 수준끼리 묶여야 해독하기 쉬운 코드

테스트에 대한 질문: 책에서 `위 쪽으로 많이 연결된 함수를 테스트하는 것이 더 가치 있다`라고 기재.

```tsx
// 상황
// convertToGrid는 이번 장에 배운 계층형 구조에서 상위 쪽.
// 테스트를 통해서 다른 개발자 추후에 함수를 변경시킨다고 해도, 
// 특정 기간 조회 시, 동일한 반환 값을 가져야 함을 테스트 할 때도, 
// 상위 계층인 convertToGrid가 아닌 내부 함수들(하위 계층을) 테스트 하는 것이 맞은지?
// 추가적으로, 테스트 코드 작성에 관해서 참고할 수 있는 library? 
const { data } = useQuery({
	...
	select: (data) => convertToGrid(data)
})

return(
	<Grid data={data ?? []} >
		<Column />
		<Column />
	</Grid>
)
```