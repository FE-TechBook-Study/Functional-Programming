### 이번 장에서 살펴볼 내용

- 해시 맵에 저장된 값을 다루기 위한 고차 함수를 만든다.
- 중첩된 데이터를 고차 함수로 쉽게 다루는 방법을 배운다.
- 재귀를 이해하고 안전하게 재귀를 사용하는 방법을 살펴본다.
- 깊이 중첩된 엔티티에 추상화 벽을 적용해서 얻을 수 있는 장점을 이해한다.

## update() 도출하기

함수 이름에 있는 **암묵적 인자 냄새가 있어 암묵적 인자를 드러내**어 리팩터링하였다.

이후에도 해당 함수가 비슷하되 하려는 동작만 다를 경우, **함수 본문을 콜백으로 바꾸어** 동작을 함수 인자로 받도록 한다.

```tsx
// before
function incrementField(item, field) {
  let value = itme[field];
  let newValue = value + 1;
  let newItem = objectSet(item, field, newValue);
  return newItem;
}

// after
function updateField(item, field, modify) {
  let value = item[field]; // 조회
  let newValue = modify(value); // 바꾸기
  let newItem = objectSet(item, field, newValue); // 설정

  return newItem; // 바꾼 객체를 리턴(카피-온-라이트)
}

function incrementField(item, field) {
  return updateField(item, field, (value) => {
    return value + 1;
  });
}
```

## 값을 바꾸기 위해 update() 사용하기

update()는 modify()를 item(해시 맵)에 사용할 수 있도록 해준다.

update()는 특정 값(field)을 다루는 동작을 받아 특정키가 있는 해시 맵에 적용한다.

이것은 중첩된 문맥 안에 있는 값에 함수를 적용하는 것으로 볼 수 있다.

## updateOption() 도출하기

2 depth 의 중첩된 필드 수정할 경우 다음과 같이 구현할 수 있다.

```tsx
function incrementSize(item) {
	return update(item, 'options', (options) => {
		return update(options, 'size', increment);
	}
}
```

그러나, 이 코드에는 냄새가 두 개 있다.

### 암묵적 인자 두 개를 명시적 인자로 변경하기

```tsx
// 1. 암묵적 option 인자 -> 명시적 option 인자
function incrementOption(item, option) {
	return update(item, 'options', (options) => {
		return update(options, option, increment);
	}
}

// 2. 암목적 modify 인자 -> 명시적 modify 인자
function updateOption(item, option, modify) {
	// 여전히 함수 이름에 있는 것(option)을 본문에서 참조하고 있다.
	return update(item, 'options', (options) => {
		return update(options, option, modify);
	}
}
```

## update2() 도출하기

update2()는 두 단계로 중첩된 어떤 객체에도 쓸 수 있는 함수이다. 그래서 함수를 쓸 때 두 개의 키가 필요하다.

```tsx
// 암묵적 인자가 있는 코드 -> 명시적 인자가 있는 코드
function update2(object, key1, key2, modify) {
  return update(object, key1, (value1) => {
    return update(value1, key2, modify);
  });
}
```

## nestedUpdate() 도출하기

updateX()는 update() 안에 updateX-1()을 불러주면 된다.

update()는 첫 번째 키만 사용하고 나머지 키와 modify 함수는 updateX-1()이 사용한다.

```tsx
function update3(object, key1, key2, key3, modify) {
  // x만큼의 키
  return update(object, key1, (value1) => {
    return update2(value1, key2, key3, modify); // 첫 번째 키는 제외
  });
}
```

**위의 3을 어떻게 명시적 인자로 바꿀 수 있을까?**

→ 깊이(depth)라는 인자를 추가해보자.

```tsx
function updateX(object, depth, key1, key2, key3, modify) {
  return update(object, key1, (value1) => {
    return updateX(value1, depth - 1, key2, key3, modify);
  });
}
```

단서는 **키의 개수와 순서**가 중요한다는 점이다.

이 단서는 배열 자료 구조가 필요하다는 것을 말한다.

모든 키를 배열로 넘기면 어떻게 될까? 그렇게 하면 depth 인자는 배열의 길이이다.

```tsx
function updateX(object, keys, modify) {
  if (keys.length === 0) {
    return modify(object);
  }

  let key1 = keys[0];
  let restOfKeys = drop_first(keys);
  return update(object, key1, (value1) => {
    return updateX(value1, restOfKeys, modify);
  });
}
```

이제 키 길이에 상관없이 쓸 수 있는 updateX()가 생겼다.

updateX()는 일반적으로 nestedUpdate()라고 부른다.

## 깊이 중첩된 데이터에 추상화 벽 사용하기

깊이 중첩된 데이터를 사용할 때 너무 많은 것을 기억해야 하는 어려움이 있다.

중첩된 각 단계의 데이터 구조를 모두 기억해야 한다.

문제를 해결하는 열쇠는 같은 작업을 하면서 알아야 할 데이터 구조를 줄이는 것이다.

추상화 벽을 통해 그렇게 할 수 있다.

추상화 벽에 함수를 만들고 의미 있는 이름을 붙여주는 것이다.

추상화 벽을 만들 때는 사용하려는 데이터의 이해도를 높일 수 있는 방향으로 해야한다.

```tsx
// before
// 각 데이터 구조에 어떤 키가 있는 기억하기 어렵다.
httpGet('http://my-blog.com/category/blog', (blogCategory) => {
	renderCategory(blogCategory, ['posts', '12', 'author', 'name'], capitalize));
});

// after

// 분류에 있는 블로그 글이 어떤 구조인지 몰라도 함수를 쓸 수 있다.
// 분류의 구조 같은 구체적인 부분은 추상화 벽 뒤로 숨긴다.
// 블로그 글 구조에 대해서는 콜백에 맡긴다.
function updatePostById(category, id, modifyPost) {
	return nestedUpdate(category, ['posts', id], modifyPost);
}

// 명확한 이름
// 블로그 글 안에 글쓴이가 어떤 구조로 저장되어 있는지 몰라도 함수를 쓸 수 있다.
// 사용자를 처리하는 방법은 modifyUser가 알고 있다.
function updateAuthor(post, modifyUser) {
	return update(post, 'author', modifyUser);
}

// 명확한 이름
// capitalizeName을 쓸 때 키를 몰라도 된다.
function capitalizeName(user) {
	return update(user, 'name', capitalize);
}

// 이제 모두 합친다.
updatePostById(blogCategory, 12, (post) => {
	return updateAuthor(post, capitalizeName);
});
```

- 기억해야할 것이 줄었다.
- 동작의 이름이 있으므로 각각의 동작을 기억하기 쉽다.

## 요점 정리

- update()는 일반적인 패턴을 구현한 함수형 도구이다. update()를 사용하면 객체 안에서 값을 꺼내 변경하고 다시 설정하는 일을 수동으로 하지 않아도 된다.
- nestedUpdate()는 깊이 중첩된 데이터를 다루는 함수형 도구이다. 바꾸려고 하는 값이 어디 있는지 가리키는 키 경로만 알면 중첩된 데이터를 쉽게 바꿀 수 있다.
- 보통 일반적인 반복문은 재귀보다 명확하다. 하지만 중첩된 데이터를 다룰 때는 재귀가 더 쉽고 명확하다.
- 재귀는 스스로 불렀던 곳이 어디인지 유지하기 위해 스택을 사용한다. 재귀 함수에서 스택은 중첩된 데이터 구조를 그대로 반영한다.
- 깊이 중첩된 데이터는 이해하기 어렵다. 깊이 중첩된 데이터를 다룰 때 모든 데이터 구조와 어떤 경로에 어떤 키가 있는지 기억해야 한다.
- 많은 키를 가지고 있는 깊이 중첩된 구조에 추상화 벽을 사용하면 알아야 할 것이 줄어든다. 추상화 벽으로 깊이 중첩된 데이터 구조를 쉽게 다룰 수 있다.
