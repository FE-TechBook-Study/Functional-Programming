# Ch 6

### 이번 장에서 살펴볼 내용

- 데이터가 바뀌지 않도록 하기 위해 카피-온-라이트를 적용한다.
- 배열과 객체를 데이터에 쓸 수 있는 카피-온-라이트 동작을 만든다.
- 깊이 중첩된 데이터도 카피-온-라이트가 잘 동작하게 만든다.

# 연습 문제 1

**조건**

1. add_contact() 가 전역변수에 접근하면 안됩니다.mailing_list를 인자로 받아 복사하고 변경한 다음 리턴해야 합니다.
2. add_contact() 함수의 리턴값을 mailing_list 전역 변수에 할당해야 합니다.

변경 전 코드

```tsx
let mailing_list = [];

function add_contact(email) {
  mailing_list.push(email);
}

function submit_form_handler(event) {
  let form = event.target;
  let email = form.elements["email"].value;
  add_contact(email);
}
```

변경 후 코드

```tsx
let mailing_list = [];

function add_contact(mailing_list, email) {
  const new_mailing_list = mailing_list.slice();
  new_mailing_list.push(email);
  return new_mailing_list;
}

function submit_form_handler(event) {
  let form = event.target;
  let email = form.elements["email"].value;
  mailing_list = add_contact(mailing_list, email);
}
```

🧐 궁금한 점 : 함수형 코딩 측면에서 두 코드의 차이점이 무엇인가?

```tsx
function add_contact(mailing_list, email) {
  const new_mailing_list = mailing_list.slice(); // 전역 변수 매개변수로 받아서 복사
  new_mailing_list.push(email);
  return new_mailing_list;
}

function add_contact(email) {
  const new_mailing_list = mailing_list.slice(); // 전역 변수 바로 복사
  new_mailing_list.push(email);
  return new_mailing_list;
}
```

✅ GPT-4 답변

- **함수형 프로그래밍 원칙**:
  - **첫 번째 코드**는 함수형 프로그래밍의 원칙을 더 잘 따릅니다. 함수형 프로그래밍에서는 함수가 외부 상태(전역 변수)에 의존하지 않도록 설계하는 것이 중요합니다. `add_contact` 함수가 `mailing_list`를 매개변수로 받음으로써, 이 함수는 외부 상태에 의존하지 않고, 매개변수로 주어진 리스트에만 의존합니다.
  - **두 번째 코드**는 전역 변수 `mailing_list`에 직접 접근하여 복사합니다. 이는 함수형 프로그래밍의 원칙에서 벗어나는 것으로, 함수가 외부 상태에 의존하고, 전역 상태를 변경할 위험이 있습니다.
- **유연성 및 재사용성**:
  - **첫 번째 코드**는 `add_contact` 함수가 외부로부터 `mailing_list`를 매개변수로 받기 때문에 더 유연합니다. 다양한 리스트에 대해 동일한 `add_contact` 함수를 사용할 수 있습니다.
  - **두 번째 코드**는 `mailing_list` 전역 변수에 직접 접근하므로, 이 함수는 특정 전역 변수에만 작동합니다. 다른 리스트에 대해 재사용할 수 없습니다.
- **디버깅 및 테스트 용이성**:
  - **첫 번째 코드**는 외부 상태에 의존하지 않으므로 테스트가 더 용이합니다. 함수가 특정 입력에 대해 항상 동일한 출력을 반환하기 때문에 단위 테스트가 더 쉽습니다.
  - **두 번째 코드**는 전역 상태에 의존하기 때문에 테스트가 어려울 수 있으며, 전역 상태가 변경될 경우 예측하기 어려운 버그가 발생할 가능성이 있습니다.

# 연습 문제2

.pop() 메서드를 카피 - 온 - 라이트 버전으로 바꿔 보세요.

```jsx
let a = [1, 2, 3, 4];
let b = a.pop();
console.log(a); // [1, 2, 3]
console.log(b); // 4
```

1. 읽기 함수와 쓰기 함수로 분리하기

```jsx
// 마지막 요소 제거된 배열 반환 함수
function drop_list(arr) {
  const copy_arr = arr.slice();
  copy_arr.pop();
  return copy_arr;
}
// 마지막 요소 반환 함수
function drop_last_element(arr) {
  return arr[arr.length - 1];
}
```

1. 값 두 개를 리턴하는 함수로 만들기

```tsx
function pop(arr) {
  let copy_arr = arr.slice();
  let first = copy_arr.pop();
  return {
    first: first,
    arr: copy_arr,
  };
}
```

# 불변 데이터 구조를 읽는 것은 계산이다

## 변경 가능한 데이터를 읽는 것은 액션이다.

변경 가능한 값을 읽을 때마다 다른 값을 읽을 수도 있다. 따라서 변경 가능한 데이터를 읽는 것은 액션이다.

## 쓰기는 데이터를 변경 가능한 구조로 만든다.

쓰기는 데이터를 바꾸기 때문에 데이터를 변경 가능한 구조로 만든다.

## 어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터이다.

쓰기를 모두 없앤다면 데이터는 생성 이후 바뀌지 않는다. 따라서 불변 데이터이다.

## 불변 데이터 구조를 읽는 것은 계산이다.

어떤 데이터를 불변형으로 만들었다면 그 데이터에 모든 읽기는 계산이다.

## 쓰기를 읽기로 바꾸면 코드에 계산이 많아진다.

데이터 구조를 불변형으로 만들수록 코드에 더 많은 계산이생기고 액션은 줄어든다.

# 불변 데이터 구조는 충분히 빠르다

일반적으로 불변 데이터 구조는 변경 가능한 데이터 구조보다 메모리를 더 많이 쓰고 느리다.

하지만 불변 데이터 구조를 사용하면서 대용량의 고성능 시스템을 구현하는 사례는 많이 있다. 이런 사례는 불변 데이터도 일반 애플리케이션에 쓰기 충분히 빠르다는 증거이다.

## 언제든 최적화할 수 있다.

애플리케이션을 개발할 때 예상하기 힘든 병목 지점이 항상 있다. 그래서 성능 개선을 할 때는 보통 미리 최적화하지 말라고 한다.

불변 데이터 구조를 사용하고 속도가 느린 부분이 있다면 그때 최적화하라.

## 가비지 콜렉터는 매우 빠르다.

대부분의 언어는 가비지 콜렉터 성능 개선을 위해 꾸준히 연구해 왔다. 어떤 가비지 콜렉터는 한두 개의 시스템 명령어로 메모리를 비울 수 있을 만큼 최적화되었다.

## 생각보다 많이 복사하지 않는다.

데이터 구조의 최상위 단계만 복사하는 것을 얕은 복사라고 한다. 얕은 복사는 같은 메모리를 가리키는 참조에 대한 복사본을 만든다. 이것을 구조적 공유라고 한다.

구조적 공유: 두 개의 중첩된 데이터 구조가 어떤 참조를 공유하는 것을 말한다. 데이터가 바뀌지 않는 불변 데이터 구조라면 구조적 공유는 안전하다. 구조적 공유는 메모리를 적게 사용하고, 모든 것을 복사하는 것보다 빠르다.

## 함수형 프로그래밍 언어에는 빠른 구현체가 있다.

데이터 구조를 복사할 때 최대한 많은 구조를 공유한다. 그래서 더 적은 메모리를 사용하고 결국 가비지 콜렉터의 부담을 줄여준다. 구현은 우리가 한 것과 같은 카피-온-라이트를 기반으로 한다.

# 연습 문제3

카피-온-라이트 방식으로 객체에 값을 설정하는 `objectSet()` 함수를 만들어 보세요.

```tsx
function objectSet(object, key, value) {
  let copy = Object.assign({}, object);
  copy[key] = value;
  return copy;
}
```

# 요점 정리

- 함수형 프로그래밍에서는 불변 데이터가 필요하다. 계산에서는 변경 가능한데이터에 쓰기를 할 수 없다.
- 카피-온-라이트는 데이터를 불변형으로 유지할 수 있는 원칙이다. 복사본을 만들고 원본 대신 복사본을 변경하는 것을 말한다.
- 카피-온-라이트는 값을 변경하기 전에 얕은 복사를 한다. 그리고 리턴한다. 이렇게 하면 통제할 수 있는 범위에서 불변성을 구현할 수 있다.
- 보일러 플레이트 코드(여러 곳에서 비슷한 코드가 반복되는 코드)를 줄이기 위해 기본적인 배열과 객체 동작에 대한 카피-온-라이트 버전을 만들어 두는 것이 좋다.
