# Ch 6

### 이번 장에서 살펴볼 내용

- 데이터가 바뀌지 않도록 하기 위해 카피-온-라이트를 적용한다.
- 배열과 객체를 데이터에 쓸 수 있는 카피-온-라이트 동작을 만든다.
- 깊이 중첩된 데이터도 카피-온-라이트가 잘 동작하게 만든다.

# 연습 문제 1

**조건**

1. add_contact() 가 전역변수에 접근하면 안됩니다.mailing_list를 인자로 받아 복사하고 변경한 다음 리턴해야 합니다.
2. add_contact() 함수의 리턴값을 mailing_list 전역 변수에 할당해야 합니다.

변경 전 코드

```tsx
let mailing_list = [];

function add_contact(email) {
  mailing_list.push(email);
}

function submit_form_handler(event) {
  let form = event.target;
  let email = form.elements["email"].value;
  add_contact(email);
}
```

변경 후 코드

```tsx
let mailing_list = [];

function add_contact(mailing_list, email) {
  const new_mailing_list = mailing_list.slice();
  new_mailing_list.push(email);
  return new_mailing_list;
}

function submit_form_handler(event) {
  let form = event.target;
  let email = form.elements["email"].value;
  mailing_list = add_contact(mailing_list, email);
}
```

🧐 궁금한 점 : 함수형 코딩 측면에서 두 코드의 차이점이 무엇인가?

```tsx
function add_contact(mailing_list, email) {
  const new_mailing_list = mailing_list.slice(); // 전역 변수 매개변수로 받아서 복사
  new_mailing_list.push(email);
  return new_mailing_list;
}

function add_contact(email) {
  const new_mailing_list = mailing_list.slice(); // 전역 변수 바로 복사
  new_mailing_list.push(email);
  return new_mailing_list;
}
```

✅ GPT-4 답변

- **함수형 프로그래밍 원칙**:
  - **첫 번째 코드**는 함수형 프로그래밍의 원칙을 더 잘 따릅니다. 함수형 프로그래밍에서는 함수가 외부 상태(전역 변수)에 의존하지 않도록 설계하는 것이 중요합니다. `add_contact` 함수가 `mailing_list`를 매개변수로 받음으로써, 이 함수는 외부 상태에 의존하지 않고, 매개변수로 주어진 리스트에만 의존합니다.
  - **두 번째 코드**는 전역 변수 `mailing_list`에 직접 접근하여 복사합니다. 이는 함수형 프로그래밍의 원칙에서 벗어나는 것으로, 함수가 외부 상태에 의존하고, 전역 상태를 변경할 위험이 있습니다.
- **유연성 및 재사용성**:
  - **첫 번째 코드**는 `add_contact` 함수가 외부로부터 `mailing_list`를 매개변수로 받기 때문에 더 유연합니다. 다양한 리스트에 대해 동일한 `add_contact` 함수를 사용할 수 있습니다.
  - **두 번째 코드**는 `mailing_list` 전역 변수에 직접 접근하므로, 이 함수는 특정 전역 변수에만 작동합니다. 다른 리스트에 대해 재사용할 수 없습니다.
- **디버깅 및 테스트 용이성**:
  - **첫 번째 코드**는 외부 상태에 의존하지 않으므로 테스트가 더 용이합니다. 함수가 특정 입력에 대해 항상 동일한 출력을 반환하기 때문에 단위 테스트가 더 쉽습니다.
  - **두 번째 코드**는 전역 상태에 의존하기 때문에 테스트가 어려울 수 있으며, 전역 상태가 변경될 경우 예측하기 어려운 버그가 발생할 가능성이 있습니다.

# 연습 문제2

.pop() 메서드를 카피 - 온 - 라이트 버전으로 바꿔 보세요.

```jsx
let a = [1, 2, 3, 4];
let b = a.pop();
console.log(a); // [1, 2, 3]
console.log(b); // 4
```

1. 읽기 함수와 쓰기 함수로 분리하기

```jsx
// 마지막 요소 제거된 배열 반환 함수
function drop_list(arr) {
  const copy_arr = arr.slice();
  copy_arr.pop();
  return copy_arr;
}
// 마지막 요소 반환 함수
function drop_last_element(arr) {
  return arr[arr.length - 1];
}
```

1. 값 두 개를 리턴하는 함수로 만들기

```tsx
function pop(arr) {
  let copy_arr = arr.slice();
  let first = copy_arr.pop();
  return {
    first: first,
    arr: copy_arr,
  };
}
```

# 불변 데이터 구조를 읽는 것은 계산이다

## 변경 가능한 데이터를 읽는 것은 액션이다.

변경 가능한 값을 읽을 때마다 다른 값을 읽을 수도 있다. 따라서 변경 가능한 데이터를 읽는 것은 액션이다.

## 쓰기는 데이터를 변경 가능한 구조로 만든다.

쓰기는 데이터를 바꾸기 때문에 데이터를 변경 가능한 구조로 만든다.

## 어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터이다.

쓰기를 모두 없앤다면 데이터는 생성 이후 바뀌지 않는다. 따라서 불변 데이터이다.

## 불변 데이터 구조를 읽는 것은 계산이다.

어떤 데이터를 불변형으로 만들었다면 그 데이터에 모든 읽기는 계산이다.

## 쓰기를 읽기로 바꾸면 코드에 계산이 많아진다.

데이터 구조를 불변형으로 만들수록 코드에 더 많은 계산이생기고 액션은 줄어든다.

# 불변 데이터 구조는 충분히 빠르다

일반적으로 불변 데이터 구조는 변경 가능한 데이터 구조보다 메모리를 더 많이 쓰고 느리다.

하지만 불변 데이터 구조를 사용하면서 대용량의 고성능 시스템을 구현하는 사례는 많이 있다. 이런 사례는 불변 데이터도 일반 애플리케이션에 쓰기 충분히 빠르다는 증거이다.

## 언제든 최적화할 수 있다.

애플리케이션을 개발할 때 예상하기 힘든 병목 지점이 항상 있다. 그래서 성능 개선을 할 때는 보통 미리 최적화하지 말라고 한다.

불변 데이터 구조를 사용하고 속도가 느린 부분이 있다면 그때 최적화하라.

## 가비지 콜렉터는 매우 빠르다.

대부분의 언어는 가비지 콜렉터 성능 개선을 위해 꾸준히 연구해 왔다. 어떤 가비지 콜렉터는 한두 개의 시스템 명령어로 메모리를 비울 수 있을 만큼 최적화되었다.

## 생각보다 많이 복사하지 않는다.

데이터 구조의 최상위 단계만 복사하는 것을 얕은 복사라고 한다. 얕은 복사는 같은 메모리를 가리키는 참조에 대한 복사본을 만든다. 이것을 구조적 공유라고 한다.

구조적 공유: 두 개의 중첩된 데이터 구조가 어떤 참조를 공유하는 것을 말한다. 데이터가 바뀌지 않는 불변 데이터 구조라면 구조적 공유는 안전하다. 구조적 공유는 메모리를 적게 사용하고, 모든 것을 복사하는 것보다 빠르다.

## 함수형 프로그래밍 언어에는 빠른 구현체가 있다.

데이터 구조를 복사할 때 최대한 많은 구조를 공유한다. 그래서 더 적은 메모리를 사용하고 결국 가비지 콜렉터의 부담을 줄여준다. 구현은 우리가 한 것과 같은 카피-온-라이트를 기반으로 한다.

# 연습 문제3

카피-온-라이트 방식으로 객체에 값을 설정하는 `objectSet()` 함수를 만들어 보세요.

```tsx
function objectSet(object, key, value) {
  let copy = Object.assign({}, object);
  copy[key] = value;
  return copy;
}
```

# 요점 정리

- 함수형 프로그래밍에서는 불변 데이터가 필요하다. 계산에서는 변경 가능한데이터에 쓰기를 할 수 없다.
- 카피-온-라이트는 데이터를 불변형으로 유지할 수 있는 원칙이다. 복사본을 만들고 원본 대신 복사본을 변경하는 것을 말한다.
- 카피-온-라이트는 값을 변경하기 전에 얕은 복사를 한다. 그리고 리턴한다. 이렇게 하면 통제할 수 있는 범위에서 불변성을 구현할 수 있다.
- 보일러 플레이트 코드(여러 곳에서 비슷한 코드가 반복되는 코드)를 줄이기 위해 기본적인 배열과 객체 동작에 대한 카피-온-라이트 버전을 만들어 두는 것이 좋다.

# Ch 7

### 이번 장에서 살펴볼 내용

- 레거시 코드나 신뢰할 수 없는 코드로부터 내 코드를 보호하기 위해 방어적 복사를 만든다.
- 얕은 복사와 깊은 복사를 비교한다.
- 카피-온-라이트와 방어적 복사를 언제 사용하면 좋은지 알 수 있다.

# 방어적 복사는 원본이 바뀌는 것을 막아 준다

신뢰할 수 없는 코드와 데이터를 주고받는 문제를 푸는 방법은 복사본 만드는 것이다.

1. 바뀔 수도 있는 데이터가 신뢰할 수 없는 코드에서 안전지대로 들어온다.
2. 들어온 데이터로 깊은 복사본을 만들고 변경 가능한 원본은 버린다.
3. 신뢰할 수 있는 코드만 복사본을 쓰기 때문에 데이터는 바뀌지 않는다.

안전지대에서 나가는 데이터도 바뀌면 안된다. 안전지태 밖으로 나가는 데이터는 신뢰할 수 없는 코드가 값을 변경할 수가 있어서 변경하지 못하도록 해야 한다.

1. 나가는 데이터도 깊은 복사본을 만들어 내보낸다.

**들어오고 나가는 데이터의 복사본을 만드는 것이 방어적 복사가 동작하는 방식**이다.

안전지대에 불변성을 유지하고, 바뀔 수도 있는 데이터가 안전지대로 들어오지 못하도록 하는 것이 방어적 복사의 목적이다.

```tsx
function add_item_to_cart(name, price) {
	let cart_copy = deepCopy(shopping_cart); // 데이터를 전달하기 전에 복사
	black_friday_promotion(cart_copy);
	shopping_cart = deepCopy(cart_copy); // 데이터를 전달한 후에 복사
```

→ 방어적 복사를 사용하면 데이터가 바뀌는 것을 막아 불변성을 지킬 수 있다. 원본이 바뀌지 않도록 막아주기 때문에 방어적이다.

# 방어적 복사 규칙

## 규칙1: 데이터가 안전한 코드에서 나갈 때 복사하기

변경 불가능한 데이터가 신뢰할 수 없는 코드로 나갈 때, 아래 단계로 원본 데이터를 보호할 수 있다.

1. 불변성 데이터를 위한 깊은 복사본을 만든다.
2. 신뢰할 수 없는 코드로 복사본을 전달한다.

## 규칙2: 안전한 코드로 데이터가 들어올 때 복사하기

신뢰할 수 없는 코드에서 변경될 수도 잇는 데이터가 들어온다면 다음 단계를 따른다.

1. 변경될 수도 있는 데이터가 들어오면 바로 깊은 복사본을 만들어 안전한 코드로 전달한다.
2. 복사본을 안전한 코드에서 사용한다.

# 방어적 복사가 익숙할 수도 있다

## 웹 API속에 방어적 복사

대부분의 웹 기반 API는 암묵적으로 방어적 복사를 한다.

JSON 데이터가 API에 요청으로 들어왔다고 해보자.

클라이언트는 데이터를 인터넷을 통해 API로 보내려고 직렬화한다. 이때 JSON 데이터는 깊은 복사본이다.

서비스가 잘 동작하면 JSON으로 응답한다. 이때 JSON도 역시 깊은 복사본이다.

방어적 복사로 서로 다른 코드와 원칙을 가진 서비스들이 문제 없이 통신할 수 있다.

# 👩🏻‍💻 카피-온-라이트와 방어적 복사는 비슷한 것 같습니다. 정말 다른 것인가요? 둘 다 필요한가요?

A. 카피-온-라이트와 방어적 복사 모두 불변성을 유지하기 위해 사용한다. 어떻게 보면 하나만 있어도 될 것 같다. 사실 안전지대에서도 방어적 복사로 불변성을 유지할 수 있다.

하지만 방어적 복사는 깊은 복사를 한다. 깊은 복사는 위에서 아래로 모든 계층의 중첩된 데이터를 복사하기 때문에 얕은 복사보다 더 많은 비용이 든다.

안전지대에서는 데이터를 전달할 때 많은 복사를 하지 않아도 된다. 많은 복사본 때문에 연산과 메모리를 낭비하는 것을 막으려면 가능한 안전지대에서는 카피-온-라이트를 사용하는 것이 좋다. 그래서 두 원칙은 함께 사용해야 한다.

|        | 카피-온-라이트                                                                       | 방어적 복사                                               |
| ------ | ------------------------------------------------------------------------------------ | --------------------------------------------------------- |
| 언제   | 통제할 수 있는 데이터를 바꿀 때 사용한다.                                            | 신뢰할 수 없는 코드와 데이터를 주고받아야 할 때 사용한다. |
| 어디서 | 안전지대 어디서나 쓸 수 있다. 사실 카피-온-라이트가 불변성을 가진 안전지대를 만든다. | 안전지대의 경계에서 데이터가 오고 갈 때 사용한다.         |
| 방식   | 얕은 복사(상대적으로 적은 비용)                                                      | 깊은 복사(상대적으로 많은 비용)                           |
| 규칙   | 1. 바꿀 데이터의 얕은 복사를 만든다.                                                 |

2. 복사본을 변경한다.
3. 복사본을 리턴한다. | 1. 안전지대로 들어오는 데이터에 깊은 복사를 만든다.
4. 안전지대에서 나가는 데이터에 깊은 복사를 만든다. |

# 요점정리

- 방어적 복사는 불변성을 구현하는 원칙이다. 데이터가 들어오고 나갈 때 복사본을 만든다.
- 방어적 복사는 깊은 복사를 한다. 그래서 카피-온-라이트보다 비용이 더 크다.
- 카피-온-라이트와 다르게 방어적 복사는 불변성 원칙을 구현하지 않은 코드로부터 데이터를 보호해준다.
- 복사본이 많이 필요하지 않기 때문에 카피-온-라이트를더 많이 사용한다. 방어적 복사는 신뢰할 수 없는 코드와 함께 사용할 때만 사용한다.
- 깊은 복사는 위에서 아래로 중첩된 데이터를 전체를복사한다. 얕은 복사는 필요한 부분만 최소한으로 복사한다.
