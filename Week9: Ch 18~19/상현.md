# 상현
## 18. 반응형 아키텍처와 어니언 아키텍처

목표

- 반응형 아키텍처로 순차적 액션을 파이프라인으로 만드는 방법 학습
- 상태 변경을 다루기 위한 기본형 만들기
- 도메인과 현실 세계의 상호작용을 위해 어니언 아키텍처 만들기
- 여러 계층에 어니언 아키텍처를 적용하는 방법 알아보기
- 전통적인 계층형 아키텍처와 어니텅 아키텍처를 비교해 보기

### 반응형 아키텍처

코드에 나타난 순차적 액션을 표시

핵심원칙은 이벤트에 대한 반응으로 일어날 일을 지정하는 것

웹 서비스와 UI에 잘 어울림

코드에 3가지 중요한 영향을 줌

1. 원인과 효과가 결합된 것을 분리
    
    ![image](https://kooku0.github.io/assets/images/18.2-885cd79476a72d073bdb922c00fb2fc9.jpg)
    
    - 다수의 이벤트에 대한 콜백으로 전부 하나씩 추가해주는 것이 있다면 콜백을 분리하여 다수의 이벤트가 일어나면 실행될 수 있게 반응형을 추가
    - 그러나 문제가 없는데 분리하는 것은 오히려 이해하기 어려운 구조로 갈 수 있다. 이 책에서 나오는 장바구니처럼 원인과 효과의 중심이 없다면 분리하지 않기
2. 여러 단계를 파이프라인으로 처리
    - 여러 개의 계산을 연결하여 처리
3. 타임라인이 유연해짐
    
    ![타임라인 유연](https://kooku0.github.io/assets/images/18.5-56c4e2d6e39951dba512109f657a35f8.jpg)
    
    - 순서를 정의하는 방법을 뒤집기 때문에 자연스럽게 타임라인이 적은 부분으로 분리
    - 타임라인이 많아지면 문제지만, 공유하는 자원이 없으면 문제 없음

### 어니언 아키텍처(Onion Architecture)

![어니언 아키텍처](https://kooku0.github.io/assets/images/18.7-55b0600f9c5d5e56ef68f4a1b83a6408.jpg)

반응형보다는 더 넓은 범위에서 사용. 서비스 전체를 구성하는데 사용되기 때문에 바깥 세계와 상호작용을 하는 부분을 다룸

반응형과 같이 사용할 수 있지만 반응형이 어니언 내부에 포함되어 있는 형태를 가지며 서로 의존하지 않음

액션에서 계산을 빼내면 의도하지 않아도 어니언 아키텍처 구조 성립

3가지 층

- 인터렉션 계층: 바깥세상에 영향을 주거나 받는 액션
- 도메인 계층: 비즈니스 규칙을 정의하는 계산
- 언어 계층: 언어 유틸리티와 라이브러리

3가지 규칙

- 현실 세계와 상호작용은 인터렉션 계층에서만 작용
- 계층에서 호출하는 방향은 중심 방향
- 계층은 외부에 어떤 계층이 있는지 모름

외부 서비스를 바꾸기 쉽다 = 변경성, 좋은 인프라보다 좋은 도메인이 중요

**프로그램의 핵심 로직을 도메인 규칙(domain rule) 또는 비즈니스 규칙(business rule)**

- 모든 로직은 도메인 로직(비즈니스 로직)이 아니다. 도메인 로직은 도메인 관련 용어를 사용한다
    - 규칙에는 제품, 이미지, 가격 등의 용어가 사용

## 19. 함수형 프로그래밍 여행에 앞서

### 꼭 기억해야 하는 것

어떤 경우에는 액션에 계산이 숨어 있습니다.

- 계산을 빼는 것은 귀찮지만 재사용성, 테스트 용이성, 가독성을 위해 가치 있는 일
- 넓은 관점에서 보면 결국 어니언 아키텍처로 구상

고참 함수를 사용하면 추상화에 대한 개념이 넓어집니다.

- 고차함수를 사용하면 저수준의 코드를 반복적 작성 방지. 이로 인해 도메인에 집중 가능

코드에서 시간의 의미는 마음대로 바꿀 수 있습니다.

- 코드가 실행되는 순서를 이해하는 것이 중요
- 타임라인 다이어그램으로 시간의 흐름에 따라 코드실행 시각화 가능

### 기술을 배우고 사용하는 방법(혼자 짜집기한 부제)

투 트랙

1. 샌드박스: 연습하는 공간
    1. 연습 문제, 사이드 프로젝트, 제품 코드에서 버려진 branch
2. 제품: 기술이 익숙해진 것 같다는 생각이 든다면 적용해보기
    1. 코드 리팩터링, 신규 기능, 리뉴얼, 멘토링

수학적 지식 얻기

- 람다 대수, 콤비네티어, 타입 이론, 카테고리 이론, 이펙트 시스템(모나드 ,어플리커티브 펑터)

## 발표할 것

아키텍처(Architecture), 구조(structure), 디자인 패턴(design pattern) 모두 프로그램을 작성하는데 많이 나오는데 같은 개념?

> StackOverFlow에서 가장 추천많이 받은 글 + GPT의 글 + 의역(`의역 표시`)을 토대로 작성. 그러나 항상 논쟁거리이며 모두가 동의는 하지 않음
> 

### 아키텍처(Architecture)

정의: 시스템의 전반적인 고수준(추상화) 원칙과 패턴의 설계

- 구조보다 “동적”이고 시스템이 시간에 따라 어떻게 진화, 확장 가능, 유지보수성을 보장할 수 있는지 표현
- 예) `자동자의 아키텍처: 어디서 부품을 수급하고, 인력 배치는 어떻게 하고, 이후 수리를 위해서 어떻게 조립할 거고 등등`

해결범위: 시스템의 전반적인 고수준부터 하위 수준까지 전부 가능

### 구조(Structure)

정의: 시스템이나 소프트웨어 내부 구성 요소들이 어떻게 배열되고 서로 연결되는지

- 아키텍처와는 다르게 시스템의 “정적” 측면에 집중하여 어떻게 정렬되고 배치되는지를 표현
- 예) `자동자의 구조: 자동자는 엔진, 엑셀, 브레이크, 본넷, 와이퍼 등등으로 이루어져 있고 배치는 어떻게 되어 있다`

해결범위: 시스템의 형태부터 하위 수준까지 전부 가능

### 디자인 패턴(Design Patterns)

정의: 소프트웨어 디자인 과정에서 자주 발생하는 문제들에 대한 일반적인 해결책

- 고수준의 형태(구조, 아키텍처)를 작은 단위의 문제로 해결할 수 있게 도와줌
- 예) Observer Pattern: 소프트웨어 내부의 기능 중에 무언가 변경되면 이를 감지하여 이벤트 전파를 해주는 역할(`자동차로 따지면 메인보드?`)

해결범위: 저수준 단위(`컴포넌트 내부`)의 문제 또는 중간범위(`페이지 단위`)의 문제

### 여기서 알 수 있는 것:

- 다수의 사람들은 (우측으로 갈 수록  하위) 아키텍처 > 구조 > 디자인 패턴 순으로 범위를 이해
    - 테오의 “[프론트엔드에서 MV* 아키텍쳐란 무엇인가요](https://velog.io/@teo/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-MV-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)?”**:** “아키텍처라는 것은 그러니까 좋은 구조를 만드는 거죠”
- 구조는 정적인 측면에 집중한다. `즉, 의도가 들어가지 않은 아키텍처의 한 순간 snapshot으로 이해가 가능할 수 있다고 본다`
- 한 프로젝트 안에서 서로간 독립적으로 존재할 수 있다. 또한 서로에게 영향을 준다
- React에 적용해본다면?
    - 아키텍처: FSD(Feature-Sliced Desing) 아키텍처를 기반으로 컴포넌트를 작성하고 REST API로 통신, `@`을 사용하여 모듈화를 표현
    - 구조: 내부 구조를 모듈화는 각 기능별로 조직화하고 디렉터리(폴더 구조) 구성을 잡는다
    - 디자인: DropDown을 작성하기 위해 Compound Pattern을 이용한다
- 최근 원티드 무료강의에 나온 강사님의 의견을 추가하자면 모든 이론들은 Trade-Off가 있기에 은탄환은 아니다. 기능적 요구사항과 비기능적 요구사항을 보고 그에 부합하는 환경을 만다는 것이 중요.

[What's the difference between design patterns and architectural patterns?](https://stackoverflow.com/questions/4243187/whats-the-difference-between-design-patterns-and-architectural-patterns)