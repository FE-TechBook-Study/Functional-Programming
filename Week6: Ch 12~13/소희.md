### 이번 장에서 살펴볼 내용

- 함수형 도구 map(), filter(), reduce()에 대해 배운다.
- 배열에 대한 반복문을 함수형 도구로 바꾸는 방법에 대해 알아본다.
- 함수형 도구를 어떻게 구현하는지 알아본다.

# 코드 냄새 하나와 리팩터링 두 개

앞 장에서 리팩터링으로 코드에 중복을 없애고 더 좋은 추상화를 만들었다.

그리고 그 과정에서 일급 값과 고차 함수를 만들었다.

### 코드의 냄새: 함수 이름에 있는 암묵적 인자

이 코드의 냄새는 일급 값으로 바꾸면 표현력이 더 좋아진다. **함수 본문에서 사용하는 어떤 값이 함수 이름에 나타난다면 함수 이름에 있는 암묵적 인자는 코드의 냄새가 된다.** 아래에 나오는 리팩터링으로 해결할 수 있다.

**특징**

1. 거의 똑같이 구현된 함수가 있다.
2. 함수 이름이 구현에 있는 다른 부분을 가리킨다.

### 리팩터링: 암묵적 인자를 드러내기

암묵적 인자를 드러내기 리팩터링은 암묵적 인자가 일급 값이 되도록 함수에 인자를 추가한다.

이렇게 하면 잠재적 중복을 없애고 코드의 목적을 더 잘 표현할 수 있다.

**단계**

1. 함수 이름에 있는 암묵적 인자를 확인한다.
2. 명시적인 인자를 추가한다.
3. 함수 본문에 하드 코딩된 값을 새로운 인자로 바꾼다.
4. 함수를 호출하는 곳을 고친다.

### 리팩터링: 함수 본문을 콜백으로 바꾸기

함수 본문을 콜백으로 바꾸기 리팩터링으로 함수 본문에 어떤 부분(비슷한 함수에 있는 서로 다른 부분)을 콜백으로 바꾼다. 이렇게 하면 일급 함수로 어떤 함수에 동작을 전달할 수 있다.

이 방법은 원래 있던 코드를 고차 함수로 만드는 가장 강력한 방법이다.

**단계**

1. 함수 본문에서 바꿀 부분의 앞부분과 뒷부분을 확인한다.
2. 리팩터링 할 코드를 함수로 빼낸다.
3. 빼낸 함수의 인자로 넘길 부분을 또 다른 함수로 빼낸다.

## reduce 함수를 사용할 때, 초깃값을 결정하는 방법

1. 계산이 어떤 값에서 시작하는가
2. 빈 배열을 사용하면 어떤 값을 리턴할 것인가
3. 비즈니스 규칙이 있는가

## reduce로 할 수 있는 것들

### 실행 취소/실행 복귀

리스트 형태의 사용자 입력에 reduce()를 적용한 것이 현재 상태라고 생각해 보면, 실행 취소는 리스트의 마지막 사용자 입력을 없애는 것이라고 할 수 있다.

### 테스트할 때 사용자 입력을 다시 실행하기

시스템의 처음 상태가 초깃값이고 사용자 입력이 순서대로 리스트에 있을 때 reduce()로 모든 값을 합쳐 현재 상태를 만들 수 있다.

### 시간 여행 디버깅

변경 사항을 어떤 시점으로 되돌릴 수 있다.

### 회계 감사 추적

과거에 어떤 일이 있었는지 기록할 수 있다. 어떤 과정을 통해 일이 생겼는지도 알 수 있다.

# reduce로 filter와 map 구현하기

```tsx
const userInputList = [1, 2, 3, 4, 5];

const customFilter = (array, conditionFn) => {
  return array.reduce((acc, cur) => {
    if (conditionFn(cur)) {
      acc.push(cur);
    }
    return acc;
  }, []);
};

const isEven = (num) => num % 2 === 0;
const filteredList = customFilter(userInputList, isEven);

console.log(filteredList); // 결과: [2, 4]
```

```tsx
const userInputList = [1, 2, 3, 4, 5];

const customMap = (array, transformFn) => {
  return array.reduce((acc, cur) => {
    acc.push(transformFn(cur));
    return acc;
  }, []);
};

const multiplyByTwo = (num) => num * 2;
const mappedList = customMap(userInputList, multiplyByTwo);

console.log(mappedList); // 결과: [2, 4, 6, 8, 10]
```

### 이번 장에서 살펴볼 내용

- 복합적인 쿼리로 데이터를 조회하기 위해 함수형 도구를 조합하는 방법을 배운다.
- 복잡한 반복문을 함수형 도구 체인으로 바꾸는 방법을 이해한다.
- 데이터 변환 파이프라인을 만들어 작업을 수행하는 방법을 배운다.

# Stream Fusion (스트림 결합)

**Stream Fusion (스트림 결합)**은 주로 함수형 프로그래밍 언어에서 사용되는 최적화 기법으로, 여러 데이터 변환 연산을 결합하여 중간 데이터를 최소화하고 성능을 향상시키는 방법이다.

이는 데이터 스트림을 처리할 때, 각 연산을 독립적으로 수행하지 않고, 가능한 한 결합하여 하나의 루푸에서 처리하는 것을 의미한다.

## **Stream (스트림)**

Stream (스트림)은 데이터를 일련의 연속적인 요소로 표현하고 처리하는 개념이다.

데이터 처리를 위한 추상화된 방법으로, 입력 데이터의 흐름을 순차적으로 처리하는 데 유용하다.

마치 물이 파이프를 통해 흐르듯이, 데이터도 스트림을 통해 하나씩 순차적으로 처리할 수 있다.

### 왜 스트림을 쓰는가?

1. 효율성:
   1. 스트림을 사용하면 메모리를 아낄 수 있다. 데이터 전체를 한꺼번에 처리하는 대신, 데이터를 한 번에 하나씩 처리해서 메모리를 적게 사용한다.
2. 가독성:
   1. 스트림을 사용하면 코드가 더 읽기 쉬워진다. 데이터 처리 과정이 한눈에 들어오기 때문.
3. 성능:
   1. 필요할 때까지 계산을 미루는 게으른 평가(lazy evaluation)를 통해 불필요한 연산을 피할 수 있다.

### 스트림의 예

JavaScript에서는 `map`, `filter`, `reduce` 등의 배열 메서드가 스트림과 비슷한 방식으로 데이터 처리를 추상화한다.

```tsx
// 데이터 배열
const data = [1, 2, 3, 4, 5];

// 스트림을 사용한 데이터 처리
const transformed = data
  .map((x) => x * 2) // 각 요소를 2배로 변환
  .filter((x) => x > 5); // 5보다 큰 요소만 필터링

console.log(transformed); // [6, 8, 10]
```

### 중간 배열이란?

위의 예제에서 `map` 메서드는 각 요소를 2배로 만든 새로운 배열을 만들고, `filter` 메서드는 그 배열에서 5보다 큰 요소만 모은 또 다른 새로운 배열을 만든다.

이 중간에 만들어지는 배열을 “중간 배열”이라고 한다.

중간 배열이 만들어지면 메모리를 더 많이 사용하게 된다.

### 배열 메서드는 일부 상황에서는 효율성이 떨어질 수 있다. 그러나,

1. **가독성:**
   1. 배열 메서드는 코드의 가독성을 크게 높인다. 데이터 변환 과정을 명확하게 보여주고, 함수형 프로그래밍 스타일을 지원한다.
2. **편리성:**
   1. 배열 메서드는 매우 편리하고 사용하기 쉽다. 복잡한 데이터 변환 작업을 간단한 메서드 체인으로 표현할 수 있다.
3. **최적화:**
   1. 자바스크립트 엔진은 배열 메서드를 내부적으로 최적화하고 있다.
      1. 최적화된 알고리즘 사용
      2. lazy evaluation (게으른 평가) - 필요할 때만 연산 수행
      3. JIT (Just-In-Time) 컴파일러 최적화 - 코드가 실행하기 전에 실시간 최적화
      4. Inline caching - 호출된 메서드 결과 캐시하고 재사용

### 중간 배열을 피할 수 있는 방법

그럼에도 불구하고, 중간 배열을 피하고 더 효율적으로 데이터를 처리하고 싶다면, 다음 방법들도 고려할 수 있다.

1. **반복문 사용**

   단일 반복문을 사용해 `map` 과 `filter` 작업을 결합할 수 있다.

   ```tsx
   const data = [1, 2, 3, 4, 5];
   const transformed = [];
   for (const x of data) {
     const y = x * 2;
     if (y > 5) {
       transformed.push(y);
     }
   }
   console.log(transformed); // [6, 8, 10]
   ```

2. **Lodash 라이브러리 사용**

   ```tsx
   const _ = require("lodash");

   const data = [1, 2, 3, 4, 5];

   // _.chain를 사용한 데이터 처리
   const transformed = _.chain(data)
     .map((x) => x * 2) // 각 숫자를 2배로 변환
     .filter((x) => x > 5) // 5보다 큰 숫자만 선택
     .value(); // 최종 결과를 반환

   console.log(transformed); // [6, 8, 10]
   ```

   Lodash와 같은 유틸리티 라이브러리는 데이터 변환을 효율적으로 할 수 있는 다양한 함수들을 제공한다.

   `.chain` 을 사용하면 메서드 체인에서 중간 배열을 최소화할 수 있다.

   - **how?**
     `.chain` 메서드를 사용하면 연산을 체인으로 묶어서 중간 배열을 최소화할 수 있다. 이는 메모리를 더 효율적으로 사용할 수 있게 해준다.
     위 코드에서 `.chain` 은 Lodash의 체인으로 데이터를 감싸고, `.map` 와 `.filter` 메서드가 체인으로 연결되어 중간 배열을 만들지 않고 최종 결과를 계산한다.
